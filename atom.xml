<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷子欲-前端博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lengziyu.com/"/>
  <updated>2016-10-14T15:59:02.536Z</updated>
  <id>http://blog.lengziyu.com/</id>
  
  <author>
    <name>lengziyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Yarn - Javascript 新一代套件管理</title>
    <link href="http://blog.lengziyu.com/2016/10/14/yarn-a-new-javascript-pkg/"/>
    <id>http://blog.lengziyu.com/2016/10/14/yarn-a-new-javascript-pkg/</id>
    <published>2016-10-14T15:25:51.000Z</published>
    <updated>2016-10-14T15:59:02.536Z</updated>
    
    <content type="html"><![CDATA[<p>日前，Facebook 发布了全新的 JS 套件管理工具 <a href="https://github.com/yarnpkg/yarn" target="_blank" rel="external">Yarn</a>，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。<br>在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。<br><a id="more"></a></p>
<h2 id="Yarn-提供一个更快更稳定的套件管理方案"><a href="#Yarn-提供一个更快更稳定的套件管理方案" class="headerlink" title="Yarn 提供一个更快更稳定的套件管理方案"></a>Yarn 提供一个更快更稳定的套件管理方案</h2><ol>
<li>透过 yarn.lock ，锁住套件版本，因此可以确保安装之套件在每台机器上都能保持一致。</li>
<li>安装过的套件，都会加入到 global cache 中，下次有砍掉要重装，或是不同资料夹要装，都可以在无网络情況底下安裝。</li>
<li>非常快，平行化处理每个 operation，全新的 resolving 演算法。</li>
</ol>
<h2 id="特性功能"><a href="#特性功能" class="headerlink" title="特性功能"></a>特性功能</h2><p>除了让安装过程更快更可靠，Yarn 还有额外的特性来更好地简化依赖管理的工作流。</p>
<ul>
<li>兼容 npm 和 bower 工作流，并且支持混合注册。</li>
<li>能够限制已安装模块的证书以及输出证书信息。</li>
<li>暴露一个稳定公开的JS API，通过构建工具提供抽象的日志记录。</li>
<li>可读、最小化、良好的命令行输出。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 以前装过 npm 再安装 yarn</div><div class="line">npm install -g yarn</div><div class="line"><span class="comment"></span></div><div class="line">// 直接安装 (mac为例，其余官网有介绍)</div><div class="line">curl -o- -L <span class="keyword">https</span>://yarnpkg.com/install.sh | bash</div><div class="line"><span class="comment"></span></div><div class="line">// 一般安装 (等同 npm install)</div><div class="line">yarn</div><div class="line"><span class="comment"></span></div><div class="line">// 安装特定套件 (等同 npm install --save)</div><div class="line">yarn <span class="built_in">add</span> react         </div><div class="line">yarn <span class="built_in">add</span> react@<span class="number">15.3</span><span class="number">.2</span></div><div class="line"><span class="comment"></span></div><div class="line">// 更新特定套件 (等同 npm upgrade)</div><div class="line">yarn upgrade react</div><div class="line"><span class="comment"></span></div><div class="line">// 移除特定套件 (等同 npm uninstall)</div><div class="line">yarn remove react</div><div class="line"><span class="comment"></span></div><div class="line">// 新增 package.json</div><div class="line">yarn init</div><div class="line"><span class="comment"></span></div><div class="line">// 新增全域套件</div><div class="line">yarn <span class="built_in">global</span> <span class="built_in">add</span></div><div class="line"><span class="comment"></span></div><div class="line">// 跑 script</div><div class="line">yarn run</div><div class="line"><span class="comment"></span></div><div class="line">// 其他常用选项</div><div class="line"><span class="comment">--offline   (离线模式，只拉 cache)</span></div><div class="line"><span class="comment">--flat      (将套件扁平化，一個资料夹只会有一個套件)</span></div><div class="line"><span class="comment">--dev       (加入到 devDependencies)</span></div><div class="line"><span class="comment">--peer      (加入到 peerDependencies)</span></div><div class="line"><span class="comment">--optional  (加入到 optionalDependencies)</span></div></pre></td></tr></table></figure>
<h2 id="Cheat"><a href="#Cheat" class="headerlink" title="Cheat"></a>Cheat</h2><table><br><thead><tr><br><th>NPM</th><br><th>YARN</th><br><th>说明</th><br></tr></thead><br><tbody><br><tr><br><td>npm init</td><br><td>yarn init</td><br><td>初始化某个项目</td><br></tr><br><tr><br><td>npm install/link</td><br><td>yarn install/link</td><br><td>默认的安装依赖操作</td><br></tr><br><tr><br><td>npm install taco —save</td><br><td>yarn add taco</td><br><td>安装某个依赖，并且默认保存到package.</td><br></tr><br><tr><br><td>npm uninstall taco —save</td><br><td>yarn remove taco</td><br><td>移除某个依赖项目</td><br></tr><br><tr><br><td>npm install taco —save-dev</td><br><td>yarn add taco —dev</td><br><td>安装某个开发时依赖项目</td><br></tr><br><tr><br><td>npm update taco —save</td><br><td>yarn upgrade taco</td><br><td>更新某个依赖项目</td><br></tr><br><tr><br><td>npm install taco –global</td><br><td>yarn global add taco</td><br><td>安装某个全局依赖项目</td><br></tr><br><tr><br><td>npm publish/login/logout</td><br><td>yarn publish/login/logout</td><br><td>发布/登录/登出，一系列NPM Registry操作</td><br></tr><br><tr><br><td>npm run/test</td><br><td>yarn run/test</td><br><td>运行某个命令</td><br></tr><br></tbody><br></table>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/" target="_blank" rel="external">Yarn: A new package manager for JavaScript</a></li>
<li><a href="https://blog.getexponent.com/yarn-a-new-program-for-installing-javascript-dependencies-44961956e728#.qf8fmeg4g" target="_blank" rel="external">Yarn: a new program for installing JavaScript dependencies</a></li>
<li><a href="https://shift.infinite.red/npm-vs-yarn-cheat-sheet-8755b092e5cc#.dcd5qeolm" target="_blank" rel="external">npm-vs-yarn-cheat-sheet</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日前，Facebook 发布了全新的 JS 套件管理工具 &lt;a href=&quot;https://github.com/yarnpkg/yarn&quot;&gt;Yarn&lt;/a&gt;，这是一个新的快速安全可信赖的可以替代NPM的依赖管理工具。&lt;br&gt;在取代npm客户端和其他包管理器现有工作流的同时，又保留了对npm代理的兼容性。它拥有与现有的工作流相同的特性，只是操作起来更快、更安全、更可靠。&lt;br&gt;
    
    </summary>
    
      <category term="yarn" scheme="http://blog.lengziyu.com/categories/yarn/"/>
    
    
      <category term="yarn" scheme="http://blog.lengziyu.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>Redux 简明教程（转）</title>
    <link href="http://blog.lengziyu.com/2016/10/13/Redux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.lengziyu.com/2016/10/13/Redux-学习笔记/</id>
    <published>2016-10-13T12:26:49.000Z</published>
    <updated>2016-10-13T12:43:41.608Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>
<p>可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个<a href="https://github.com/gaearon/redux-devtools" target="_blank" rel="external">时间旅行调试器可以编辑后实时预览</a>。<br><a id="more"></a></p>
<p>Redux 除了和 React 一起用外，还支持其它界面库。<br>它体小精悍（只有2kB）且没有任何依赖。</p>
<h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>Redux 由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>首先要区分 <code>store</code> 和 <code>state</code><br><code>state</code> 是应用的状态，一般本质上是一个普通对象<br>例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能<br>那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 应用初始 state，本代码块记为 code-1 **/</span></div><div class="line">&#123;</div><div class="line">  <span class="attribute">counter</span>: <span class="number">0</span>,</div><div class="line">  todos: []</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>store</code> 是应用状态 <code>state</code> 的管理者，包含下列四个函数：</p>
<ul>
<li>getState() # 获取整个 state</li>
<li>dispatch(action) # ※ 触发 state 改变的【唯一途径】※</li>
<li>subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener</li>
<li>replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用</li>
</ul>
<p>二者的关系是：<code>state = store.getState()</code><br>Redux 规定，一个应用只应有一个单一的 <code>store</code>，其管理着唯一的应用状态 <code>state</code><br>Redux 还规定，不能直接修改应用的状态 <code>state</code>，也就是说，下面的行为是不允许的：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">state</span> = store.getState()</div><div class="line"><span class="keyword">state</span>.counter = <span class="keyword">state</span>.counter + <span class="number">1</span> // 禁止在业务逻辑中直接修改 <span class="keyword">state</span></div></pre></td></tr></table></figure>
<p>若要改变 <code>state</code>，必须 <code>dispatch</code> 一个 <code>action</code>，这是修改应用状态的不二法门</p>
<div class="tip"><br>现在您只需要记住 action 只是一个包含 type 属性的普通对象即可<br>例如 { type: ‘INCREMENT’ }<br></div><br>上面提到，<code>state</code> 是通过 <code>store.getState()</code> 获取，那么 <code>store</code> 又是怎么来的呢？<br>想生成一个 <code>store</code>，我们需要调用 Redux 的 <code>createStore</code>：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; from <span class="string">'redux'</span></div><div class="line">...</div><div class="line"><span class="keyword">const</span> store = createStore(reducer, initialState) <span class="comment">// store 是靠传入 reducer 生成的哦！</span></div></pre></td></tr></table></figure><br><br><div class="tip"><br>现在您只需要记住 reducer 是一个 函数，负责更新并返回一个新的 state<br>而 initialState 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染）<br></div>

<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>上面提到，<code>action</code>（动作）实质上是包含 <code>type</code> 属性的普通对象，这个 <code>type</code> 是我们实现用户行为追踪的关键<br>例如，增加一个待办事项 的 <code>action</code> 可能是像下面一样：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 本代码块记为 code-2 **/</span></div><div class="line">&#123;</div><div class="line">  <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">  <span class="attribute">payload</span>: &#123;</div><div class="line">    <span class="attribute">id</span>: <span class="number">1</span>,</div><div class="line">    <span class="attribute">content</span>: <span class="string">'待办事项1'</span>,</div><div class="line">    <span class="attribute">completed</span>: false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了<br>也就是说，下面这些 action 都是合法的：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 如下都是合法的，但就是不够规范 **/</span></div><div class="line">&#123;</div><div class="line">  <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">  <span class="attribute">id</span>: <span class="number">1</span>,</div><div class="line">  <span class="attribute">content</span>: <span class="string">'待办事项1'</span>,</div><div class="line">  <span class="attribute">completed</span>: false</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">  <span class="attribute">abcdefg</span>: &#123;</div><div class="line">    <span class="attribute">id</span>: <span class="number">1</span>,</div><div class="line">    <span class="attribute">content</span>: <span class="string">'待办事项1'</span>,</div><div class="line">    <span class="attribute">completed</span>: false</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>虽说没有约束，但最好还是遵循<a href="https://github.com/acdlite/flux-standard-action" target="_blank" rel="external">规范</a></strong><br>如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 本代码块记为 code-3 **/</span></div><div class="line">&#123;</div><div class="line">  <span class="attribute">counter</span>: <span class="number">0</span>,</div><div class="line">  <span class="attribute">todos</span>: [&#123;</div><div class="line">    <span class="attribute">id</span>: <span class="number">1</span>,</div><div class="line">    <span class="attribute">content</span>: <span class="string">'待办事项1'</span>,</div><div class="line">    <span class="attribute">completed</span>: false</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>刨根问底，action 是谁生成的呢？</p>
<h2 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h2><p><div class="tip"><br>Action Creator 可以是同步的，也可以是异步的<br></div><br>顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）<br>例如下面就是一个 “新增一个待办事项” 的 Action Creator：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 本代码块记为 code-4 **/</span></div><div class="line"><span class="built_in">var</span> id = <span class="number">1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attribute">type</span>: <span class="string">'ADD_TODO'</span>,</div><div class="line">    <span class="attribute">payload</span>: &#123;</div><div class="line">      <span class="attribute">id:</span><span class="string"> id</span>++,</div><div class="line">      <span class="attribute">content</span>: content, <span class="comment">// 待办事项内容</span></div><div class="line">      <span class="attribute">completed</span>: <span class="literal">false</span>  <span class="comment">// 是否完成的标识</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">--!</span> 本代码块记为 <span class="attr">code-5</span> <span class="attr">--</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"todoInput"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content = $(<span class="string">'#todoInput'</span>).val() <span class="comment">// 获取输入框的值</span></div><div class="line">  <span class="keyword">var</span> action = addTodo(content) <span class="comment">// 执行 Action Creator 获得 action</span></div><div class="line">  store.dispatch(action) <span class="comment">// 改变 state 的不二法门：dispatch 一个 action！！！</span></div><div class="line">&#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 本代码块记为 code-6 **/</span></div><div class="line">&#123;</div><div class="line">  <span class="attribute">counter</span>: <span class="number">0</span>,</div><div class="line">  todos: [&#123;</div><div class="line">    id: <span class="number">1</span>,</div><div class="line">    content: <span class="string">'待办事项1'</span>,</div><div class="line">    completed: false</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attribute">id</span>: <span class="number">2</span>,</div><div class="line">    content: <span class="string">'待办事项2'</span>,</div><div class="line">    completed: false</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action)</strong><br>刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，<br>Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？<br>又是谁负责“写入”的呢？悬念即将揭晓…</p>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p><strong>Reducer 必须是同步的纯函数</strong><br>用户每次 dispatch(action) 后，都会触发 reducer 的执行<br>reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState<br>最后会用 reducer 的返回值 nextState 完全替换掉原来的 state</p>
<p><div class="tip"><br>注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改<br>Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作<br>例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ … 等返回副本的函数<br></div><br>在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/** 本代码块记为 code-<span class="number">7</span> **/</div><div class="line">var initState = &#123;</div><div class="line">  counter: <span class="number">0</span>,</div><div class="line">  todos: []</div><div class="line">&#125;</div><div class="line"></div><div class="line">function reducer(<span class="keyword">state</span>, action) &#123;</div><div class="line">  // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※</div><div class="line">  if (!<span class="keyword">state</span>) <span class="keyword">state</span> = initState</div><div class="line"></div><div class="line">  switch (action.type) &#123;</div><div class="line">    case 'ADD_TODO':</div><div class="line">      var nextState = _.cloneDeep(<span class="keyword">state</span>) // 用到了 lodash 的深克隆</div><div class="line">      nextState.todos.push(action.payload)</div><div class="line">      return nextState</div><div class="line"></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">    // 由于 nextState 会把原 <span class="keyword">state</span> 整个替换掉</div><div class="line">    // 若无修改，必须返回原 <span class="keyword">state</span>（否则就是 undefined）</div><div class="line">      return <span class="keyword">state</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通俗点讲，就是 reducer 返回啥，state 就被替换成啥</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>store 由 Redux 的 createStore(reducer) 生成</li>
<li>state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象</li>
<li>action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生</li>
<li>改变 state 必须 dispatch 一个 action</li>
<li>reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数</li>
<li>reducer 必须返回值，否则 nextState 即为 undefined</li>
<li>实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单）</li>
</ul>
<p><strong>Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState</strong></p>
<p>原文地址：<a href="https://github.com/kenberkeley/redux-simple-tutorial" target="_blank" rel="external">Redux 简明教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。&lt;/p&gt;
&lt;p&gt;可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个&lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;时间旅行调试器可以编辑后实时预览&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="redux" scheme="http://blog.lengziyu.com/categories/redux/"/>
    
    
      <category term="redux" scheme="http://blog.lengziyu.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>React JSX语法</title>
    <link href="http://blog.lengziyu.com/2016/10/12/react-jsx-grammar/"/>
    <id>http://blog.lengziyu.com/2016/10/12/react-jsx-grammar/</id>
    <published>2016-10-12T12:00:40.000Z</published>
    <updated>2016-10-13T12:08:55.221Z</updated>
    
    <content type="html"><![CDATA[<p>JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。<br><a id="more"></a><br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">JSX</span>=JavaScriptXML</div></pre></td></tr></table></figure></p>
<p>JSX可以理解为在JS中编写与XML类似的语言（与XML有本质上的不同），它的目的不是要在浏览器或者引擎中实现，也不是把其加入ECMAScript标准。它的目的是通过各种编译器将这些标记编译成标准的JS语言。</p>
<p>JSX是：</p>
<ul>
<li>基于ECMAScript的一种新特性（并不是一种新语言）</li>
<li>一种定义带属性树结构（DOM结构）的语法</li>
</ul>
<p>JSX不是：</p>
<ul>
<li>XML或者HTML</li>
<li>一种限制 （你不需要为了 React 使用 JSX，可以直接使用纯粹的 JS。但更建议使用 JSX , 因为它能定义简洁且我们熟知的包含属性的树状结构语法。）</li>
</ul>
<p>JSX的特点：</p>
<ul>
<li>类XML语法容易接受，结构清晰</li>
<li>增强JS语义</li>
<li>抽象程度高，屏蔽DOM操作，跨平台</li>
<li>代码模块化</li>
</ul>
<h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><p>JSX本身就和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"lengziyu"</span> /&gt;</span>, mountNode);</span></div></pre></td></tr></table></figure></p>
<p><strong>一、元素名</strong><br>自定义出的组件标签名，React 的 JSX 里约定分别使用首字母大、小写来区分本地组件的类和 HTML 标签。render渲染时，会把大写的组件名定义为自定义组件，把小写的组件名定义为HTML自带的标签名进行渲染。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> HelloMessage =</div></pre></td></tr></table></figure></p>
<p>JSX的标签与函数名都是使用的驼峰命名。</p>
<p>htmlFor和className<br>for和class为js的保留字，在书写for与class时需要修改为htmlFor何className，注意都是使用的驼峰命名。</p>
<p>自闭合标签<br>在 JSX 中， <mycomponent> 是合法的，而 <mycomponent> 就不合法。 所有的标签都必须闭合，可以是自闭和的形式，也可以是常规的闭合。</mycomponent></mycomponent></p>
<div class="tip"><br>注意：所有 React component 都可以采用自闭和的形式，包括div等<br></div>

<p><strong>二、子节点</strong><br>组件与组件之间就像标签与标签之间可以有嵌套关系，与HTML不同的是可以在子节点中使用求值表达式。目前， 一个 component 的 render，只能返回一个节点。如果你需要返回一堆 div ， 那你必须将你的组件用 一个div 或 span 或任何其他的组件包裹。</p>
<p><div class="tip"><br>切记，JSX 会被编译成常规的 JS； 因此返回两个函数也就没什么意义了，同样地，千万不要在三元操作符中放入超过一个子节点。<br></div><br>如果往原生 HTML 元素里传入 HTML 规范里不存在的属性，React 不会显示它们。如果需要使用自定义属性，要加 data- 前缀。</p>
<p><strong>三、求值表达式</strong><br>要使用 JavaScript 表达式作为属性值，只需把这个表达式用一对大括号 ( { } ) 包起来，不要用引号 ( “ “ )。求值表达式本身与JSX没有多大关系，是JS中的特性。它是会返回值的表达式，与语句有本质上的不同，在编写JSX时，在 { } 中不能使用语句（if语句、for语句等等）。我们不能直接使用语句，但可以把语句包裹在函数求值表达式中运用。建议把函数表达式独立出来，在 { } 调用。</p>
<p>条件判断的写法<br>你没法在JSX中使用 if-else 语句，因为 JSX 只是函数调用和对象创建的语法糖。在 { } 中使用，是不合法的JS代码，不过可以采用三元操作表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name ？ this.props.name : "World"&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"xiaowang"</span> /&gt;</span>, document.body);</span></div></pre></td></tr></table></figure></p>
<p>可以使用比较运算符“ || ”来书写，如果左边的值为真，则直接返回左边的值，否则返回右边的值，与if的效果相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name || "World"&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"xiaowang"</span> /&gt;</span>, document.body);</span></div></pre></td></tr></table></figure>
<p>也可以使用变量来书写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">getName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.name)</div><div class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.props.name</div><div class="line">      <span class="keyword">else</span></div><div class="line">          <span class="keyword">return</span> <span class="string">"world"</span></div><div class="line">  &#125;</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> name = <span class="keyword">this</span>.getName();</div><div class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"xiaowang"</span> /&gt;</span>, document.body);</span></div></pre></td></tr></table></figure></p>
<p>其中可以把变量去掉，直接在 { } 中调用函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.getName()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>四、注释</strong><br>JSX 里添加注释很容易；它们只是 JS 表达式而已。你只需要在一个标签的子节点内(非最外层)小心地用 { } 包围要注释的部分。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = (</div><div class="line">  &lt;Nav&gt;</div><div class="line">    &#123;<span class="comment">/* 一般注释, 用 &#123;&#125; 包围 */</span>&#125;</div><div class="line">    &lt;Person</div><div class="line">      <span class="comment">/* 多</span></div><div class="line">         行</div><div class="line">         注释 */</div><div class="line">      name=&#123;<span class="built_in">window</span>.isLoggedIn ? <span class="built_in">window</span>.name : <span class="string">''</span>&#125; <span class="comment">// 行尾注释</span></div><div class="line">    /&gt;</div><div class="line">  &lt;/Nav&gt;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><strong>五、样式</strong><br>尽管在大部分场景下我们应该将样式写在独立的CSS文件中，但是有时对于某个特定组件而言，其样式相当简单而且独立，那么也可以将其直接定义在JSX中。在JSX中使用样式和真实的样式也很类似，通过style属性来定义，但和真实DOM不同的是，属性值不能是字符串而必须为对象，需要注意的是属性名同样需要驼峰命名法。例如：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span> style=&#123;&#123;color: <span class="string">'#ff0000'</span>, fontSize: <span class="string">'14px'</span>&#125;&#125;&gt;Hello World.&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> style = &#123;    </div><div class="line">    <span class="attr">color</span> : <span class="string">"red"</span>,</div><div class="line">    <span class="attr">border</span> : <span class="string">"1px solid #000"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"xiaowang"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>, document.body);</span></div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要介绍了声明组件的语法JSX。看似有点神秘的JSX背后的原理非常简单：只是一种用于创建组件的XML语法。让代码直观易懂是软件项目质量的重要保证之一，这意味着代码更加容易理解和维护，出现Bug时更容易调试和修复。因此React这种采用JSX语法，以声明式的方法来直观的定义用户界面的方式，正是其最大的价值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。&lt;br&gt;
    
    </summary>
    
      <category term="react" scheme="http://blog.lengziyu.com/categories/react/"/>
    
    
      <category term="react" scheme="http://blog.lengziyu.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 数据流 Props 和 State [组件沟通]</title>
    <link href="http://blog.lengziyu.com/2016/10/11/react-props-and-state-plus/"/>
    <id>http://blog.lengziyu.com/2016/10/11/react-props-and-state-plus/</id>
    <published>2016-10-11T10:50:20.000Z</published>
    <updated>2016-10-11T11:19:19.790Z</updated>
    
    <content type="html"><![CDATA[<p>组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。</p>
<a id="more"></a>
<p>可以分为以下 3 种：</p>
<ul>
<li>【父组件】向【子组件】传值；</li>
<li>【子组件】向【父组件】传值；</li>
<li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间传值）</li>
</ul>
<h3 id="【父组件】向【子组件】传值"><a href="#【父组件】向【子组件】传值" class="headerlink" title="【父组件】向【子组件】传值"></a>【父组件】向【子组件】传值</h3><p>父组件更新子组件状态，通过传递<code>props</code>，就可以了。例子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父组件</span></div><div class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">checked</span>: <span class="literal">true</span></div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;ToggleButton text="Toggle me" checked=&#123;this.state.checked&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子组件</div><div class="line">var ToggleButton = React.createClass(&#123;</div><div class="line">  render: function () &#123;</div><div class="line">    // 从【父组件】获取的值</div><div class="line">    var checked = this.props.checked,</div><div class="line">        text = this.props.text;</div><div class="line"></div><div class="line">    return (</div><div class="line">        &lt;label&gt;&#123;text&#125;: &lt;input type="checkbox" checked=&#123;checked&#125; /&gt;&lt;/label&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>进一步讨论</p>
<p>如果组件嵌套层次太深，那么从外到内组件的交流成本就变得很高，通过 props 传递值的优势就不那么明显了。（PS：所以我建议尽可能的减少组件的层次，就像写 HTML 一样，简单清晰的结构更惹人爱）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父组件</span></div><div class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;Intermediate text="where is my son?" /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子组件1：中间嵌套的组件</div><div class="line">var Intermediate = React.createClass(&#123;</div><div class="line">  render: function () &#123;</div><div class="line">    return (</div><div class="line">      &lt;Child text=&#123;this.props.text&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子组件2：子组件1的子组件</div><div class="line">var Child = React.createClass(&#123;</div><div class="line">  render: function () &#123;</div><div class="line">    return (</div><div class="line">      &lt;span&gt;&#123;this.props.text&#125;&lt;/span&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="【子组件】向【父组件】传值"><a href="#【子组件】向【父组件】传值" class="headerlink" title="【子组件】向【父组件】传值"></a>【子组件】向【父组件】传值</h3><p>接下来，我们介绍【子组件】控制自己的 state 然后告诉【父组件】的点击状态，然后在【父组件】中展示出来。因此，我们添加一个 change 事件来做交互。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 父组件</span></div><div class="line"><span class="keyword">var</span> MyContainer = React.createClass(&#123;</div><div class="line">  <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">checked</span>: <span class="literal">false</span></div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">onChildChanged</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newState</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      <span class="attr">checked</span>: newState</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> isChecked = <span class="keyword">this</span>.state.checked ? <span class="string">'yes'</span> : <span class="string">'no'</span>;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;div&gt;Are you checked: &#123;isChecked&#125;&lt;/div&gt;</div><div class="line">        &lt;ToggleButton text="Toggle me"</div><div class="line">          initialChecked=&#123;this.state.checked&#125;</div><div class="line">          callbackParent=&#123;this.onChildChanged&#125;</div><div class="line">          /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 子组件</div><div class="line">var ToggleButton = React.createClass(&#123;</div><div class="line">  getInitialState: function () &#123;</div><div class="line">    return &#123;</div><div class="line">      checked: this.props.initialChecked</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  onTextChange: function () &#123;</div><div class="line">    var newState = !this.state.checked;</div><div class="line">    this.setState(&#123;</div><div class="line">      checked: newState</div><div class="line">    &#125;);</div><div class="line">    // 这里要注意：setState 是一个异步方法，所以需要操作缓存的当前值</div><div class="line">    this.props.callbackParent(newState);</div><div class="line">  &#125;,</div><div class="line">  render: function () &#123;</div><div class="line">    // 从【父组件】获取的值</div><div class="line">    var text = this.props.text;</div><div class="line">    // 组件自身的状态数据</div><div class="line">    var checked = this.state.checked;</div><div class="line"></div><div class="line">    return (</div><div class="line">        &lt;label&gt;&#123;text&#125;: &lt;input type="checkbox" checked=&#123;checked&#125; onChange=&#123;this.onTextChange&#125; /&gt;&lt;/label&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样做其实是依赖 props 来传递事件的引用，并通过回调的方式来实现的，这样实现不是特别好，但是在没有任何工具的情况下也是一种简单的实现方式</p>
<p>这里会出现一个我们在之前讨论的问题，就是组件有多层嵌套的情况下，你必须要一次传入回调函数给 props 来实现子组件向父组件传值或者操作。</p>
<h3 id="兄弟组件之间传值"><a href="#兄弟组件之间传值" class="headerlink" title="兄弟组件之间传值"></a>兄弟组件之间传值</h3><p>当两个组件有相同的父组件时，就称为兄弟组件（堂兄也算的）。按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的<code>props</code>。</p>
<p><strong>方式一</strong><br>通过<code>props</code>传递父组件回调函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.refresh&#125;</span>&gt;</span></div><div class="line">            更新兄弟组件</div><div class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">         &#123;this.props.text || "兄弟组件未更新"&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line">  refresh()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">text</span>: <span class="string">"兄弟组件沟通成功"</span>,</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;h2&gt;兄弟组件沟通&lt;/h2&gt;</div><div class="line">        &lt;Brother1 refresh=&#123;this.refresh()&#125;/&gt;</div><div class="line">        &lt;Brother2 text=&#123;this.state.text&#125;/&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>方式二</strong><br>但是如果组件层次太深，上面的兄弟组件沟通方式就效率低了（不建议组件层次太深）。<br>React提供了一种上下文方式（挺方便的），可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother1</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render()&#123;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.context.refresh&#125;</span>&gt;</span></div><div class="line">            更新兄弟组件</div><div class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Brother1.contextTypes = &#123;</div><div class="line">  <span class="attr">refresh</span>: React.PropTypes.any</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">         &#123;this.context.text || "兄弟组件未更新"&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Brother2.contextTypes = &#123;</div><div class="line">  <span class="attr">text</span>: React.PropTypes.any</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getChildContext()&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">refresh</span>: <span class="keyword">this</span>.refresh(),</div><div class="line">          <span class="attr">text</span>: <span class="keyword">this</span>.state.text,</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  refresh()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">text</span>: <span class="string">"兄弟组件沟通成功"</span>,</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>兄弟组件沟通<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Brother1</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">Brother2</span> <span class="attr">text</span>=<span class="string">&#123;this.state.text&#125;/</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Parent.childContextTypes = &#123;</div><div class="line">  refresh: React.PropTypes.any,</div><div class="line">  text: React.PropTypes.any,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="全局事件"><a href="#全局事件" class="headerlink" title="全局事件"></a>全局事件</h3><p>官网中提到可以使用全局事件来进行组件间的通信，官网推荐Flux（Facebook官方出的），还有Relay、Redux、trandux等第三方类库。这些框架思想都一致，都是统一管理组件state变化情况，达到数据可控目的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单的组件交流我们可以使用上面非全局事件的简单方式，但是当项目复杂，组件间层次越来越深，上面的交流方式就不太合适（当然还是要用到的，简单的交流）。强烈建议使用Flux、Relay、Redux、trandux等类库其中一种，这些类库不只适合React，像Angular等都可以使用。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/" target="_blank" rel="external">ReactJS组件间沟通的一些方法</a></li>
<li><a href="http://www.alloyteam.com/2015/09/react-redux/" target="_blank" rel="external">React 数据流管理架构之 Redux 介绍</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组件沟通因为React的单向数据流方式会有所限制，下面述说组件之间的沟通方式。&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://blog.lengziyu.com/categories/react/"/>
    
    
      <category term="react" scheme="http://blog.lengziyu.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 数据流 Props 和 State [基础介绍]</title>
    <link href="http://blog.lengziyu.com/2016/10/10/react-props-and-state/"/>
    <id>http://blog.lengziyu.com/2016/10/10/react-props-and-state/</id>
    <published>2016-10-10T11:17:09.000Z</published>
    <updated>2016-10-11T11:21:38.531Z</updated>
    
    <content type="html"><![CDATA[<p>使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。</p>
<a id="more"></a>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>React是单向数据流，从父节点传递到子节点（通过<code>props</code>）。如果顶层的某个<code>props</code>改变了，React会重渲染所有的子节点（未做性能优化）。严格意义上React只提供，也强烈建议使用这种数据交流方式。</p>
<h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><code>props</code>是<code>property</code>的缩写，可以理解为HTML标签的<code>attribute</code>。请把<code>props</code>当做只读的（不可以使用<code>this.props</code>直接修改<code>props</code>），<code>props</code>是用于整个组件树中传递数据和配置。在当前组件访问<code>props</code>，使用<code>this.props</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloWorld = React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-title</span>=<span class="string">&#123;this.props.title&#125;</span>&gt;</span>&#123;this.props.content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">title</span>=<span class="string">"this is title"</span> <span class="attr">content</span>=<span class="string">"this is content"</span>/&gt;</span>,</span></div><div class="line">    document.body</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>每个组件都有属于自己的<code>state</code>，<code>state</code>和<code>props</code>的区别在于前者之只存在于组件内部，只能从当前组件调用<code>this.setState</code>修改<code>state</code>值（不可以直接修改<code>this.state</code>）。一般我们更新子组件都是通过改变<code>state</code>值，更新新子组件的<code>props</code>值从而达到更新。</p>
<p>那如何设置默认state?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//React提供的crateClass创建方式</span></div><div class="line"><span class="keyword">var</span> Component = React.createClass(&#123;</div><div class="line">  getInitialState()&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="comment">//这里设置初始state值</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//ES6 &amp;&amp; ES7</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="keyword">this</span>.state = &#123;&#125;<span class="comment">//在ES6中的构造函数中初始化，可以之直接赋值，在其他方法中，只能使用this.setState</span></div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看一个例子，点击按钮，切换按钮的颜色：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ColorButton = React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">bColor</span>: <span class="string">'green'</span>&#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> <span class="attr">this.state.bColor</span>&#125;&#125;&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">bColor</span>: <span class="keyword">this</span>.state.bColor === <span class="string">'green'</span> ? <span class="string">'red'</span> : <span class="string">'green'</span>&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ColorButton</span> /&gt;</span>,</span></div><div class="line">    document.body</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>handleClick是用来处理我们点击事件的。</p>
<h3 id="state工作原理"><a href="#state工作原理" class="headerlink" title="state工作原理"></a>state工作原理</h3><p>通过调用setState(data, callback)方法，改变状态，就会触发React更新UI。大部分情况下，我们不需要提供callback函数。React会自动的帮我们更新UI。</p>
<h3 id="什么样的组件该有state"><a href="#什么样的组件该有state" class="headerlink" title="什么样的组件该有state"></a>什么样的组件该有state</h3><p>大部分的组件应该从props属性中获取数据并渲染。但有的时候组件得相应用户输入，同服务器交互，这些情况下会用到state。React的官方说法是：<strong>尽可能的保持你的组件无状态化</strong>。为了实现这个目标，得保持你的状态同业务逻辑分离，并减少冗余信息，尽可能保持组件的单一职责。</p>
<p>React官方推荐的一种模式就是：构建几个无状态的组件用来渲染数据，在这些之上构建一个有状态的组件同用户和服务交互，数据通过props传递给无状态的组件。我的理解大概就是这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> RenderComponent = React.createClass(&#123;</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></div><div class="line">                &#123;</div><div class="line">                    this.props['data-list'].map(function (item) &#123;</div><div class="line">                        return (<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)</div><div class="line">                    &#125;)</div><div class="line">                &#125;</div><div class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> StateComponent = React.createClass(&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">list</span>: [<span class="string">'xxx'</span>, <span class="string">'yyy'</span>]&#125;;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">RenderComponent</span> <span class="attr">data-list</span>=<span class="string">&#123;this.state.list&#125;/</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">        )</div><div class="line">    &#125;,</div><div class="line">    handleClick: function () &#123;</div><div class="line">        this.setState(&#123;list: [1, 2, 3]&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(</div><div class="line">    <span class="tag">&lt;<span class="name">StateComponent</span> /&gt;</span>,</div><div class="line">    document.body</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>UI交互会导致改变的数据。<br>state不应包含什么样的数据：1.计算过的数据；2.组件；3.从props复制的数据。<br>state应保含最原始的数据，比如说时间，格式化应该交给展现层去做。组件应在render方法里控制。</p>
<h3 id="props和state使用方式"><a href="#props和state使用方式" class="headerlink" title="props和state使用方式"></a>props和state使用方式</h3><div class="tip"><br>尽可能使用props当做数据源，state用来存放状态值（简单的数据），如复选框、下拉菜单等。<br></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用React我们首先要知道如何传递数据，组件如何沟通，才能展示我们想要的数据。下面的列子都是使用ES6语法，不懂的同学需要先学习ES6语法。&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://blog.lengziyu.com/categories/react/"/>
    
    
      <category term="react" scheme="http://blog.lengziyu.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 学习笔记</title>
    <link href="http://blog.lengziyu.com/2016/10/09/react-early-know/"/>
    <id>http://blog.lengziyu.com/2016/10/09/react-early-know/</id>
    <published>2016-10-09T12:17:35.000Z</published>
    <updated>2016-10-10T13:25:00.961Z</updated>
    
    <content type="html"><![CDATA[<p>React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：</p>
<a id="more"></a>
<h3 id="实时更新数据"><a href="#实时更新数据" class="headerlink" title="实时更新数据"></a>实时更新数据</h3><p>React使得展现数据变得简单，并且当数据改变时，React能自动保持UI的更新。</p>
<h3 id="构建通用组件"><a href="#构建通用组件" class="headerlink" title="构建通用组件"></a>构建通用组件</h3><p>React旨在构建通用组件。试试想，写React代码就是在构建组件。因为组件式封装的，所以组件使得代码的复用性、测试性和关注分离变得简单。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>React.js</strong><br>React.js 是 React 的核心库，在应用中必须先加载核心库。</p>
<p><strong>ReactDOM.js</strong><br>ReactDOM.js 是 React 的 DOM 渲染器，React 将核心库和渲染器分离开了，为了在 web 页面中显示开发的组件，需要调用 ReactDOM.render 方法， 第一个参数是 React 组件，第二个参数为 HTMLElement。</p>
<p><strong>JSX</strong><br>JSX 是 React 自定义的语法，最终 JSX 会转化为 JS 运行于页面当中。</p>
<p><strong>组件</strong><br>组件是 React 中的核心概念，页面当中的所有元素都是通过 React 组件来表达， 我们将要写的 React 代码绝大部分都是在做 React 组件的开发。</p>
<p><strong>VIRTUAL DOM</strong><br>React 抽象出来的虚拟 DOM 树，虚拟树是 React 高性能的关键。</p>
<p><strong>单向数据流：one-way reactive data flow</strong><br>React 应用的核心设计模式，数据流向自顶向下</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>创建一个简单的 <code>Hello World</code>，新建 index.html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/JSXTransformer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/app.js"</span> <span class="attr">type</span>=<span class="string">"text/jsx"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>React独创了一种JS、CSS和HTML混写的JSX格式，可以通过在页面中引入JSXTransformer这个文件进行客户端的编译，不过还是推荐在服务端编译。<br>app.js :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HelloMessage = React.createClass(&#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">"John"</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('container')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h3 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h3><p>用来创建一个组件类，编写React代码主要就是构建通用的组件。</p>
<h3 id="React-render"><a href="#React-render" class="headerlink" title="React.render"></a>React.render</h3><p>将React的模板转化为HTML，并插入到相应的DOM结构中。要注意的是，React的渲染函数并不是简单地把HTML元素复制到页面上，而是维护了一张Virtual Dom映射表。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React是Facebook和Instagram用来创建用户界面的JavaScript库。很多人将React认为是MVC中的V。 React的创建是为了解决一个问题：如何构建一个数据交互频繁的大型应用程序？为了实现这个目标，React运用了两个思想：&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://blog.lengziyu.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack基本使用配置[基础篇]</title>
    <link href="http://blog.lengziyu.com/2016/10/08/webpack-use-expo/"/>
    <id>http://blog.lengziyu.com/2016/10/08/webpack-use-expo/</id>
    <published>2016-10-08T12:28:47.000Z</published>
    <updated>2016-10-10T13:25:06.540Z</updated>
    
    <content type="html"><![CDATA[<div class="foreword">webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。<br></div>

<a id="more"></a>
<h3 id="webpack优势"><a href="#webpack优势" class="headerlink" title="webpack优势"></a>webpack优势</h3><ul>
<li>模块来源广泛，支持包括npm/bower等等的各种主流模块安装／依赖解决方案；</li>
<li>模块化规范支持全面，AMD/CommonJS一应具全；</li>
<li>插件机制完善，实现本身实现同样模块化，容易扩展；</li>
<li>Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先要安装 <a href="http://nodejs.org" target="_blank" rel="external">Node.js</a>， Node.js 自带了软件包管理器 npm，Webpack 需要 Node.js v0.6 以上支持，建议使用最新版 Node.js。<br>用 npm 全局安装 Webpack：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install webpack -g</div></pre></td></tr></table></figure></p>
<p>初始化配置文件 package.json ：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">npm</span> init</div></pre></td></tr></table></figure></p>
<p>到项目目录安装，将 webpack 添加到 package.json ：<br><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install webpack --<span class="built_in">save</span>-<span class="built_in">dev</span></div></pre></td></tr></table></figure></p>
<h3 id="webpack常用命令"><a href="#webpack常用命令" class="headerlink" title="webpack常用命令"></a>webpack常用命令</h3><ul>
<li>webpack 最基本的启动webpack命令</li>
<li>webpack -w 提供watch方法，实时进行打包更新</li>
<li>webpack -p 对打包后的文件进行压缩</li>
<li>webpack -d 提供SourceMaps，方便调试</li>
<li>webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤</li>
<li>webpack –profile 输出性能数据，可以看到每一步的耗时</li>
<li>webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</li>
</ul>
<p>前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// entry.js</span></div><div class="line">document.<span class="built_in">write</span>(<span class="string">'It works.'</span>)</div></pre></td></tr></table></figure>
<p>然后编译 entry.js 并打包到 bundle.js：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ webpack entry<span class="selector-class">.js</span> bundle.js</div></pre></td></tr></table></figure></p>
<p>打包过程会显示日志：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Hash: e964f90ec65eb2c29bb9</div><div class="line">Version: webpack 1.12.2</div><div class="line"><span class="keyword">Time:</span> 54ms</div><div class="line">    Asset     Size  Chunks             Chunk Names</div><div class="line">bundle.js  1.42 kB       0  [emitted]  main</div><div class="line">   [0] ./entry.js 27 bytes &#123;0&#125; [built]</div></pre></td></tr></table></figure></p>
<p>用浏览器打开 index.html 将会看到 It works.</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;foreword&quot;&gt;webpack是一个前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。还可以结合gulp使用，不冲突。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://blog.lengziyu.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.lengziyu.com/2016/10/08/hello-world/"/>
    <id>http://blog.lengziyu.com/2016/10/08/hello-world/</id>
    <published>2016-10-08T10:57:39.537Z</published>
    <updated>2016-10-10T11:17:37.833Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
